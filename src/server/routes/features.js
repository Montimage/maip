const express = require('express');
const fs = require('fs');
const path = require('path');
const router = express.Router();

const {
  PCAP_PATH,
  MMT_PROBE_CONFIG_PATH,
  REPORT_PATH,
  DEEP_LEARNING_PATH,
  PYTHON_CMD,
} = require('../constants');
const { listFilesByTypeAsync } = require('../utils/file-utils');
const { spawnCommand, getUniqueId } = require('../utils/utils');
const { startMMTOffline, getMMTStatus } = require('../mmt/mmt-connector');

// POST /api/features/extract
// Body: { pcapFile: string, isMalicious?: boolean }
// Runs mmt-probe to generate report CSV, then trafficToFeature.py to get a PKL, then converts PKL to CSV and returns the CSV content
router.post('/extract', async (req, res) => {
  try {
    const { pcapFile, isMalicious } = req.body || {};
    if (!pcapFile || typeof pcapFile !== 'string') {
      return res.status(400).send('Missing pcapFile');
    }
    const inputPcap = path.join(PCAP_PATH, pcapFile);
    if (!fs.existsSync(inputPcap)) {
      return res.status(400).send(`PCAP not found: ${pcapFile}`);
    }

    // Reuse existing MMT offline pipeline and poll until completion
    startMMTOffline(pcapFile, (status) => {
      if (status && status.error) {
        return res.status(401).send(status.error);
      }
      const { sessionId } = status;
      if (!sessionId) {
        return res.status(500).send('Failed to start MMT offline');
      }
      const startedSessionId = sessionId;
      const outputDir = path.join(REPORT_PATH, `report-${startedSessionId}`);
      const logFile = path.join(outputDir, `features_${startedSessionId}.log`);
      const intervalMs = 2000;
      const maxAttempts = 150;
      let attempts = 0;
      const poll = setInterval(() => {
        const s = getMMTStatus();
        const done = !s.isRunning && s.sessionId === startedSessionId;
        attempts += 1;
        if (done || attempts >= maxAttempts) {
          clearInterval(poll);
          if (!fs.existsSync(outputDir)) {
            return res.status(500).send('Output directory not found');
          }
          try {
            const csvFiles = listFilesByTypeAsync(outputDir, '.csv') || [];
            const picked = csvFiles.find(f => f !== 'security-reports.csv') || csvFiles[0];
            if (!picked) {
              return res.status(500).send('No CSV generated by mmt-probe');
            }
            const finalReportCsv = path.join(outputDir, picked);
            const baseName = path.parse(picked).name;
            const outPkl = path.join(outputDir, `${baseName}.pkl`);
            const outCsv = path.join(outputDir, `${baseName}.features.csv`);

            // Determine label choice
            const hasLabel = (isMalicious === true || isMalicious === false);
            const featParams = [
              path.join(DEEP_LEARNING_PATH, 'trafficToFeature.py'),
              finalReportCsv,
              outPkl,
              String(Boolean(isMalicious)),
            ];
            spawnCommand(PYTHON_CMD, featParams, logFile, (err2) => {
              if (err2) {
                console.error('[features] trafficToFeature.py failed:', err2.message || err2);
                return res.status(500).send('Feature extraction failed');
              }

              const pyInline = [
                '-c',
                [
                  'import pandas as pd, numpy as np, sys; ',
                  'inp=sys.argv[1]; out=sys.argv[2]; drop=(len(sys.argv)>3 and sys.argv[3]=="1"); ',
                  'df=pd.read_pickle(inp); ',
                  'df=df[df.notnull().all(axis=1)]; ',
                  'df=df.replace([np.inf, -np.inf], 0); ',
                  'if drop:\n',
                  '    cols=list(df.columns)\n',
                  '    norm=[str(c).strip().lower() for c in cols]\n',
                  '    to_drop=[cols[i] for i,n in enumerate(norm) if n=="malware"]\n',
                  '    if to_drop: df=df.drop(columns=to_drop)\n',
                  'df.to_csv(out, index=False)'
                ].join(''),
                outPkl,
                outCsv,
                hasLabel ? '0' : '1',
              ];
              spawnCommand(PYTHON_CMD, pyInline, logFile, (err3) => {
                if (err3) {
                  console.error('[features] PKL->CSV conversion failed:', err3.message || err3);
                  return res.status(500).send('Failed to convert features to CSV');
                }
                try {
                  const content = fs.readFileSync(outCsv, 'utf8');
                  return res.send({ ok: true, sessionId: startedSessionId, csvFile: path.basename(outCsv), csvContent: content });
                } catch (e) {
                  console.error('[features] Failed reading CSV:', e.message || e);
                  return res.status(500).send('Failed to read generated CSV');
                }
              });
            });
          } catch (e) {
            console.error('[features] Unexpected during post-MMT processing:', e.message || e);
            return res.status(500).send('Post-processing error');
          }
        }
      }, intervalMs);
    });
  } catch (e) {
    console.error('[features] unexpected error:', e);
    res.status(500).send(e.message || 'Unexpected error');
  }
});

module.exports = router;
